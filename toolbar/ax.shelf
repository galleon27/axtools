<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="AX" label="AX">
    <memberTool name="create octane rop"/>
    <memberTool name="create rop for bake"/>
    <memberTool name="Create Instance"/>
    <memberTool name="Delete Materials0"/>
    <memberTool name="Delete UVs"/>
    <memberTool name="UV/NO UV"/>
    <memberTool name="Unlock File"/>
    <memberTool name="Import Files"/>
    <memberTool name="Hierarchy for Octane"/>
    <memberTool name="Merge selected nodes to network"/>
    <memberTool name="Arnold UDIM"/>
    <memberTool name="Create RS Arnold Material"/>
    <memberTool name="Create Octane Arnold Material"/>
    <memberTool name="Split SOP by shop_materialpath"/>
    <memberTool name="createNull"/>
    <memberTool name="Gradient from Image"/>
    <memberTool name="Swatches"/>
    <memberTool name="Export Rops"/>
  </toolshelf>

  <tool name="GSG Octane Material" label="GSG Octane Material" icon="custom_hda_icon">
    <script scriptType="python"><![CDATA[import soptoolutils

node = soptoolutils.genericTool(kwargs, 'AX_OctaneQuickMaterial', exact_node_type=False)
node.parm('presets').set(1)
]]></script>
  </tool>

  <tool name="Solaris Material Library Fill" label="Solaris Material Library Fill" icon="custom_hda_icon">
    <script scriptType="python"><![CDATA[import hou

node = hou.selectedNodes()[0]
pane = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
cursor_position = pane.cursorPosition()

print(node)]]></script>
  </tool>

  <tool name="Gradient from Image" label="Gradient from Image" icon="custom_hda_icon">
    <script scriptType="python"><![CDATA[import hou
import os
import colorsys
import random
from PIL import Image, ImageDraw
from functools import partial
from PySide2 import QtCore, QtGui, QtWidgets

def resolve_path(path):
    try:
        expanded = hou.expandString(path)
        return os.path.normpath(expanded)
    except Exception:
        return os.path.normpath(path)

def sample_image_colors(image_path, num_samples=9, mode="default", seed=1):
    random.seed(seed)
    img = Image.open(image_path).convert("RGB")
    width, height = img.size

    sample_count = max(300, num_samples * 10)
    sampled = []
    positions_sampled = []

    for _ in range(sample_count):
        x = random.randint(0, width - 1)
        y = random.randint(0, height - 1)
        r, g, b = img.getpixel((x, y))
        rgb = (r / 255.0, g / 255.0, b / 255.0)

        if mode != "random":
            h, s, v = colorsys.rgb_to_hsv(*rgb)
            if mode == "dark" and v >= 0.4:
                continue
            elif mode == "bright" and v <= 0.6:
                continue
            elif mode == "muted" and s >= 0.4:
                continue
            elif mode == "deep" and not (s > 0.6 and v < 0.5):
                continue

        sampled.append(rgb)
        positions_sampled.append((x, y))

    if not sampled:
        sampled = [(r / 255.0, g / 255.0, b / 255.0) for _ in range(num_samples)
                   for r, g, b in [img.getpixel((random.randint(0, width - 1), random.randint(0, height - 1)))]]
        positions_sampled = [(random.randint(0, width - 1), random.randint(0, height - 1)) for _ in range(num_samples)]

    unique = []
    unique_positions = []
    for i, c in enumerate(sampled):
        if not any(all(abs(a - b) < 0.05 for a, b in zip(c, u)) for u in unique):
            unique.append(c)
            unique_positions.append(positions_sampled[i])
        if len(unique) >= num_samples:
            break

    while len(unique) < num_samples:
        unique += unique
        unique_positions += unique_positions
    unique = unique[:num_samples]
    unique_positions = unique_positions[:num_samples]

    positions = [i / (num_samples - 1) if num_samples > 1 else 0.5 for i in range(num_samples)]
    return list(zip(positions, unique)), unique_positions

def create_color_ramp(colors):
    network = hou.ui.curDesktop().paneTabOfType(hou.paneTabType.NetworkEditor)
    if not network:
        raise Exception("No network editor found")

    parent = network.pwd()
    if not parent:
        raise Exception("Could not find parent context")

    existing = None
    for node in hou.selectedNodes():
        if node.type().name() == "color":
            existing = node
            break

    if existing:
        color_node = existing
    else:
        old = parent.node("image_color_ramp")
        if old:
            old.destroy()

        color_node = parent.createNode("color", "image_color_ramp")
        color_node.parm("colortype").set(3)

        hda_node = parent.parent()
        if hda_node and hda_node.inputs():
            input_node = hda_node.inputs()[0]
            if input_node:
                color_node.setInput(0, input_node)

        color_node.moveToGoodPosition()
        color_node.setDisplayFlag(True)
        color_node.setRenderFlag(True)
        color_node.setSelected(True)

    basis = [hou.rampBasis.Linear] * len(colors)
    positions = [p for p, c in colors]
    values = [c for p, c in colors]
    ramp = hou.Ramp(basis, positions, values)

    color_node.parm("ramp").set(ramp)
    return color_node

class ImageRampUI(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super(ImageRampUI, self).__init__(parent or hou.ui.mainQtWindow())
        self.setWindowTitle("Image to Color Ramp")
        self.setMinimumWidth(400)

        self.image_path = ""
        self.num_samples = 9
        self.mode = "default"
        self.seed = 1
        self.sampled_colors = []
        self.sample_positions = []
        self.original_pixmap = None

        self.image_preview = QtWidgets.QLabel()
        self.image_preview.setAlignment(QtCore.Qt.AlignCenter)
        self.image_preview.setScaledContents(False)
        self.image_preview.setMinimumSize(400, 400)  # Force 400x400 minimum
        self.image_preview.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.color_swatches_layout = QtWidgets.QHBoxLayout()

        self.build_ui()

    def build_ui(self):
        layout = QtWidgets.QVBoxLayout()

        self.slider_label = QtWidgets.QLabel("Number of Samples: 9")
        layout.addWidget(self.slider_label)

        self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider.setMinimum(3)
        self.slider.setMaximum(20)
        self.slider.setValue(9)
        self.slider.valueChanged.connect(self.update_slider_label)
        layout.addWidget(self.slider)

        self.seed_label = QtWidgets.QLabel("Random Seed: 1")
        layout.addWidget(self.seed_label)

        self.seed_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.seed_slider.setMinimum(0)
        self.seed_slider.setMaximum(9999)
        self.seed_slider.setValue(1)
        self.seed_slider.valueChanged.connect(self.update_seed_label)
        layout.addWidget(self.seed_slider)

        mode_layout = QtWidgets.QHBoxLayout()
        self.mode_buttons = {}
        for label in ["Default", "Dark", "Bright", "Muted", "Deep", "Random"]:
            btn = QtWidgets.QPushButton(label)
            btn.clicked.connect(partial(self.set_mode, label.lower()))
            self.mode_buttons[label.lower()] = btn
            mode_layout.addWidget(btn)
        layout.addLayout(mode_layout)

        file_layout = QtWidgets.QHBoxLayout()
        file_btn = QtWidgets.QPushButton("Select Image")
        file_btn.clicked.connect(self.select_image)
        self.image_path_field = QtWidgets.QLineEdit()
        self.image_path_field.editingFinished.connect(self.handle_manual_path_input)
        file_layout.addWidget(file_btn)
        file_layout.addWidget(self.image_path_field)
        layout.addLayout(file_layout)

        layout.addWidget(self.image_preview)

        swatch_container = QtWidgets.QWidget()
        swatch_container.setLayout(self.color_swatches_layout)
        layout.addWidget(swatch_container)

        self.generate_btn = QtWidgets.QPushButton("Generate Ramp")
        self.generate_btn.clicked.connect(self.generate_ramp)
        layout.addWidget(self.generate_btn)

        self.setLayout(layout)

    def update_slider_label(self, value):
        self.num_samples = value
        self.slider_label.setText(f"Number of Samples: {value}")
        self.update_preview()

    def update_seed_label(self, value):
        self.seed = value
        self.seed_label.setText(f"Random Seed: {value}")
        self.update_preview()

    def set_mode(self, mode):
        self.mode = mode
        for m, btn in self.mode_buttons.items():
            btn.setStyleSheet("background: none")
        self.mode_buttons[mode].setStyleSheet("background-color: lightblue")
        self.update_preview()

    def select_image(self):
        path = hou.ui.selectFile(
            title="Select Image File",
            file_type=hou.fileType.Image,
            pattern="*.png *.jpg *.jpeg *.tif *.tiff *.exr"
        )
        if path:
            resolved = resolve_path(path)
            self.image_path = resolved
            self.image_path_field.setText(path)
            self.update_preview()

    def handle_manual_path_input(self):
        path = self.image_path_field.text().strip()
        if not path:
            return
        resolved = resolve_path(path)
        if not os.path.exists(resolved):
            hou.ui.displayMessage(f"File does not exist:\n{resolved}", severity=hou.severityType.Warning)
            return
        self.image_path = resolved
        self.update_preview()

    def update_preview(self):
        if not self.image_path:
            return
        try:
            img = Image.open(self.image_path).convert("RGB")
            self.sampled_colors, self.sample_positions = sample_image_colors(
                self.image_path, self.num_samples, self.mode, self.seed
            )

            img_qt = img.copy()
            max_width = 400
            max_height = 400
            img_qt.thumbnail((max_width, max_height), Image.LANCZOS)
            radius = 10
            stroke = 12
            scale_x = img_qt.width / img.width
            scale_y = img_qt.height / img.height

            draw = ImageDraw.Draw(img_qt)
            for (x, y), (_, rgb) in zip(self.sample_positions, self.sampled_colors):
                px = int(x * scale_x)
                py = int(y * scale_y)
                fill_color = tuple(int(c * 255) for c in rgb)
                draw.ellipse((px - stroke, py - stroke, px + stroke, py + stroke), fill="white")        # outer
                draw.ellipse((px - radius, py - radius, px + radius, py + radius), fill=fill_color)     # inner

            data = img_qt.tobytes("raw", "RGB")
            qimg = QtGui.QImage(data, img_qt.width, img_qt.height, QtGui.QImage.Format_RGB888)
            pixmap = QtGui.QPixmap.fromImage(qimg)
            self.original_pixmap = pixmap

            scaled_pixmap = pixmap.scaled(
                self.image_preview.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation
            )
            self.image_preview.setPixmap(scaled_pixmap)

            while self.color_swatches_layout.count():
                child = self.color_swatches_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()

            for _, color in self.sampled_colors:
                swatch = QtWidgets.QLabel()
                swatch.setFixedSize(24, 24)
                swatch.setStyleSheet(
                    f"background-color: rgb({int(color[0]*255)}, {int(color[1]*255)}, {int(color[2]*255)}); "
                    "border: 1px solid black;"
                )
                self.color_swatches_layout.addWidget(swatch)

        except Exception as e:
            hou.ui.displayMessage(f"Error loading preview: {e}", severity=hou.severityType.Error)

    def resizeEvent(self, event):
        super(ImageRampUI, self).resizeEvent(event)
        if self.original_pixmap:
            scaled_pixmap = self.original_pixmap.scaled(
                self.image_preview.size(), QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation
            )
            self.image_preview.setPixmap(scaled_pixmap)

    def generate_ramp(self):
        if not self.image_path or not self.sampled_colors:
            hou.ui.displayMessage("No image or sampled colors", severity=hou.severityType.Warning)
            return
        try:
            create_color_ramp(self.sampled_colors)
            hou.ui.displayMessage("Color ramp created successfully.")
        except Exception as e:
            hou.ui.displayMessage(f"Failed to create ramp: {e}", severity=hou.severityType.Error)

def show_image_ramp_ui():
    ui = ImageRampUI()
    ui.show()

if __name__ == "__main__" or "hou" in globals():
    show_image_ramp_ui()
]]></script>
  </tool>

  <tool name="Swatches" label="Swatches" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import struct
from PySide6 import QtWidgets, QtGui, QtCore

def cmyk_to_rgb(c, m, y, k):
    r = 1.0 - min(1.0, c * (1 - k) + k)
    g = 1.0 - min(1.0, m * (1 - k) + k)
    b = 1.0 - min(1.0, y * (1 - k) + k)
    return (r, g, b)

class SwatchLabel(QtWidgets.QLabel):
    selected_labels = set()

    def __init__(self, name, rgb, parent=None):
        super().__init__(parent)
        self.name = name
        self.rgb = rgb
        self.setFixedSize(60, 60)
        r, g, b = [int(c * 255) for c in rgb]
        self.setStyleSheet(f"background-color: rgb({r},{g},{b}); border: 1px solid black;")
        self.setToolTip(f"{name}\nRGB: {rgb}")
        self.setCursor(QtCore.Qt.OpenHandCursor)
        self._drag_active = False
        self._selected = False

    def set_selected(self, selected):
        self._selected = selected
        border = "3px solid #33AADD" if self._selected else "1px solid black"
        r, g, b = [int(c * 255) for c in self.rgb]
        self.setStyleSheet(f"background-color: rgb({r},{g},{b}); border: {border};")

    def mousePressEvent(self, event):
        if event.button() != QtCore.Qt.LeftButton:
            return

        modifiers = QtWidgets.QApplication.keyboardModifiers()
        if modifiers in [QtCore.Qt.ControlModifier, QtCore.Qt.ShiftModifier]:
            # Toggle selection
            self.set_selected(not self._selected)
            if self._selected:
                SwatchLabel.selected_labels.add(self)
            else:
                SwatchLabel.selected_labels.discard(self)
        else:
            # Clear all others
            for label in list(SwatchLabel.selected_labels):
                label.set_selected(False)
            self.set_selected(True)
            SwatchLabel.selected_labels = {self}

        self._drag_active = True
        self._start_pos = event.pos()

    def mouseMoveEvent(self, event):
        if self._drag_active and (event.pos() - self._start_pos).manhattanLength() > 5:
            self.setCursor(QtCore.Qt.ClosedHandCursor)

    def mouseReleaseEvent(self, event):
        self.setCursor(QtCore.Qt.OpenHandCursor)
        if not self._drag_active:
            return
        self._drag_active = False

        pane = hou.ui.paneTabUnderCursor()
        if not isinstance(pane, hou.NetworkEditor):
            return  # Not over a network editor

        network = pane.pwd()
        pos = pane.cursorPosition()
        selected = list(SwatchLabel.selected_labels or {self})

        spacing = hou.Vector2(1.5, -1.5)
        base_pos = pos - hou.Vector2(len(selected) / 2.0, 0.0)

        try:
            created = []
            for i, swatch in enumerate(selected):
                node = network.createNode("color")
                node.parmTuple("color").set(swatch.rgb)
                node.setPosition(base_pos + spacing * i)
                created.append(node)

            for a, b in zip(created[:-1], created[1:]):
                b.setNextInput(a)

            if created:
                created[-1].setSelected(True, clear_all_selected=True)
                pane.setCurrentNode(created[-1])
        except Exception as e:
            hou.ui.displayMessage(f"Error creating color node(s): {e}")


class SwatchViewer(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ASE Swatch Viewer")
        self.setMinimumSize(500, 400)

        layout = QtWidgets.QVBoxLayout(self)
        self.setLayout(layout)

        self.load_btn = QtWidgets.QPushButton("Load .ASE File")
        self.load_btn.clicked.connect(self.load_ase)
        layout.addWidget(self.load_btn)

        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        layout.addWidget(self.scroll_area)

        self.container = QtWidgets.QWidget()
        self.grid = QtWidgets.QGridLayout(self.container)
        self.grid.setSpacing(6)
        self.scroll_area.setWidget(self.container)

        self.console = QtWidgets.QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setMaximumHeight(100)
        self.console.setStyleSheet("background-color: #111; color: #eee; font-family: Consolas; font-size: 11px;")
        layout.addWidget(self.console)

    def log(self, message):
        self.console.appendPlainText(str(message))

    def closeEvent(self, event):
        if hasattr(hou.session, "swatch_viewer"):
            hou.session.swatch_viewer = None
        event.accept()

    def clear_grid(self):
        while self.grid.count():
            item = self.grid.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        # Clear selection set on reload
        SwatchLabel.selected_labels.clear()

    def load_ase(self):
        filepath, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select ASE File", filter="*.ase")
        if not filepath:
            self.log("No file selected.")
            return

        self.log(f"Loading ASE: {filepath}")
        self.clear_grid()
        swatches = self.parse_ase(filepath)

        row = col = 0
        for name, rgb in swatches:
            label = SwatchLabel(name, rgb)
            self.grid.addWidget(label, row, col)
            col += 1
            if col >= 6:
                col = 0
                row += 1
        self.log(f"Loaded {len(swatches)} swatches.")

    def parse_ase(self, path):
        try:
            with open(path, "rb") as f:
                data = f.read()
        except Exception as e:
            self.log(f"Error reading file: {e}")
            return []

        swatches = []
        pos = 0

        def read_u16():
            nonlocal pos
            val = struct.unpack(">H", data[pos:pos+2])[0]
            pos += 2
            return val

        def read_u32():
            nonlocal pos
            val = struct.unpack(">I", data[pos:pos+4])[0]
            pos += 4
            return val

        def read_f32():
            nonlocal pos
            val = struct.unpack(">f", data[pos:pos+4])[0]
            pos += 4
            return val

        def read_utf16():
            nonlocal pos
            strlen = read_u16()
            raw = data[pos:pos + strlen * 2]
            pos += strlen * 2
            return raw.decode('utf_16_be').rstrip('\0')

        if data[0:4] != b"ASEF":
            self.log("Invalid ASE file header.")
            return []
        
        pos = 4
        major = read_u16()
        minor = read_u16()
        block_count = read_u32()
        self.log(f"ASE version: {major}.{minor}")
        self.log(f"ASE block count: {block_count}")

        block_index = 0

        while pos < len(data):
            try:
                block_type = read_u16()
                block_len = read_u32()
                block_end = pos + block_len
                block_index += 1

                if block_type == 0x0001:  # Color entry
                    name = read_utf16()
                    color_model = data[pos:pos+4].decode("ascii").strip()
                    pos += 4

                    if color_model == "RGB":
                        r = read_f32()
                        g = read_f32()
                        b = read_f32()
                        swatches.append((name, (r, g, b)))
                        self.log(f"RGB swatch: {name} â ({r:.2f}, {g:.2f}, {b:.2f})")
                    elif color_model == "CMYK":
                        c = read_f32()
                        m = read_f32()
                        y = read_f32()
                        k = read_f32()
                        r, g, b = cmyk_to_rgb(c, m, y, k)
                        swatches.append((name + " (CMYK)", (r, g, b)))
                        self.log(f"CMYK swatch: {name} â ({r:.2f}, {g:.2f}, {b:.2f})")
                    else:
                        self.log(f"Unsupported color model: {color_model}")

                    pos += 2  # skip color type
                else:
                    self.log(f"Skipping block type: {hex(block_type)}")

                pos = block_end
            except Exception as e:
                self.log(f"Error parsing block {block_index}: {e}")
                break

        return swatches

def launch_swatch_viewer():
    if not hasattr(hou.session, "swatch_viewer") or not isinstance(hou.session.swatch_viewer, QtWidgets.QWidget):
        hou.session.swatch_viewer = SwatchViewer()
    if hou.session.swatch_viewer is not None:
        hou.session.swatch_viewer.show()
        hou.session.swatch_viewer.raise_()

launch_swatch_viewer()
]]></script>
  </tool>

  <tool name="tool_1" label="New Tool" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os
import struct
import time
from PySide2 import QtWidgets, QtGui, QtCore

def cmyk_to_rgb(c, m, y, k):
    """Convert CMYK values (0-1 range) to RGB (0-1 range)"""
    r = (1.0 - c) * (1.0 - k)
    g = (1.0 - m) * (1.0 - k)
    b = (1.0 - y) * (1.0 - k)
    return (r, g, b)

class FlowLayout(QtWidgets.QLayout):
    """Custom flow layout that arranges widgets left-to-right and wraps as needed"""
    def __init__(self, parent=None, margin=0, spacing=5):
        super(FlowLayout, self).__init__(parent)
        self.setSpacing(spacing)
        if parent is not None:
            self.setContentsMargins(margin, margin, margin, margin)
        self.item_list = []

    def addItem(self, item):
        self.item_list.append(item)

    def count(self):
        return len(self.item_list)

    def itemAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list.pop(index)
        return None

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        return self.do_layout(QtCore.QRect(0, 0, width, 0), True)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QtCore.QSize()
        for item in self.item_list:
            size = size.expandedTo(item.minimumSize())
        margins = self.contentsMargins()
        size += QtCore.QSize(margins.left() + margins.right(), margins.top() + margins.bottom())
        return size

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.do_layout(rect, False)

    def do_layout(self, rect, test_only):
        x = rect.x()
        y = rect.y()
        line_height = 0
        
        for item in self.item_list:
            wid = item.widget()
            space_x = self.spacing()
            space_y = self.spacing()
            next_x = x + item.sizeHint().width() + space_x
            if next_x - space_x > rect.right() and line_height > 0:
                x = rect.x()
                y = y + line_height + space_y
                next_x = x + item.sizeHint().width() + space_x
                line_height = 0
            
            if not test_only:
                item.setGeometry(QtCore.QRect(QtCore.QPoint(x, y), item.sizeHint()))
            
            x = next_x
            line_height = max(line_height, item.sizeHint().height())
        
        return y + line_height - rect.y()

class DebugConsole(QtWidgets.QPlainTextEdit):
    """Custom console widget for debug output"""
    def __init__(self, parent=None):
        super(DebugConsole, self).__init__(parent)
        self.setReadOnly(True)
        self.setStyleSheet("""
            QPlainTextEdit {
                background-color: #222;
                color: #ddd;
                font-family: Consolas, monospace;
                font-size: 10px;
            }
        """)
        self.setMaximumHeight(150)
    
    def log(self, message, color=None):
        timestamp = time.strftime("%H:%M:%S", time.localtime())
        msg = f"[{timestamp}] {message}"
        self.appendPlainText(msg)
        self.verticalScrollBar().setValue(self.verticalScrollBar().maximum())

class AseSwatchLoader(QtWidgets.QWidget):
    def __init__(self):
        super(AseSwatchLoader, self).__init__()
        self.setWindowTitle("ASE Swatch Loader")
        self.setMinimumSize(800, 600)
        self.swatches = []
        
        # Main layout
        self.layout = QtWidgets.QVBoxLayout()
        self.setLayout(self.layout)
        
        # File selection area
        self.file_layout = QtWidgets.QHBoxLayout()
        self.file_path = QtWidgets.QLineEdit()
        self.file_path.setReadOnly(True)
        self.file_path.setPlaceholderText("No ASE file selected")
        self.browse_btn = QtWidgets.QPushButton("Browse...")
        self.browse_btn.clicked.connect(self.load_ase_file)
        self.file_layout.addWidget(self.file_path)
        self.file_layout.addWidget(self.browse_btn)
        self.layout.addLayout(self.file_layout)
        
        # Swatch display area
        self.swatch_area = QtWidgets.QScrollArea()
        self.swatch_area.setWidgetResizable(True)
        self.swatch_container = QtWidgets.QWidget()
        self.swatch_layout = FlowLayout()
        self.swatch_container.setLayout(self.swatch_layout)
        self.swatch_area.setWidget(self.swatch_container)
        self.layout.addWidget(self.swatch_area)
        
        # Debug console
        self.debug_console = DebugConsole()
        self.console_button = QtWidgets.QPushButton("Toggle Console")
        self.console_button.setCheckable(True)
        self.console_button.setChecked(False)
        self.console_button.toggled.connect(self.toggle_console)
        self.debug_console.setVisible(False)
        
        # Status bar
        self.status_layout = QtWidgets.QHBoxLayout()
        self.status_bar = QtWidgets.QLabel("Ready")
        self.status_bar.setAlignment(QtCore.Qt.AlignLeft)
        
        self.status_layout.addWidget(self.status_bar)
        self.status_layout.addWidget(self.console_button)
        self.layout.addLayout(self.status_layout)
        self.layout.addWidget(self.debug_console)
        
        # Setup network editor drop handler
        self.drop_handler_installed = False
        self.install_drop_handler_timer = QtCore.QTimer()
        self.install_drop_handler_timer.timeout.connect(self.try_setup_drop_handler)
        self.install_drop_handler_timer.start(1000)  # Try every second until found
        
        # Make window float in Houdini
        self.setParent(hou.qt.mainWindow(), QtCore.Qt.Window)
        self.show()
    
    def toggle_console(self, visible):
        self.debug_console.setVisible(visible)
        if visible:
            self.console_button.setText("Hide Console")
        else:
            self.console_button.setText("Show Console")
    
    def log(self, message):
        """Log message to debug console"""
        self.debug_console.log(message)
        print(message)  # Also print to Houdini console
    
    def try_setup_drop_handler(self):
        """Try to setup drop handler until network editor is available"""
        if not self.drop_handler_installed:
            if self.setup_drop_handler():
                self.install_drop_handler_timer.stop()
                self.drop_handler_installed = True
    
    def setup_drop_handler(self):
        """Setup network editor to accept color drops"""
        try:
            self.log("Setting up network editor drop handler...")
            
            # Get all network editors in the current desktop
            network_editors = [pane for pane in hou.ui.curDesktop().paneTabs() 
                             if pane.type() == hou.paneTabType.NetworkEditor]
            
            if not network_editors:
                self.log("No network editor found (try opening a network editor pane)")
                return False
            
            # Use the first available network editor
            network_editor = network_editors[0]
            network_widget = None
            
            # Try multiple ways to find the widget
            try:
                network_widget = hou.qt.floatingPanelWidget(network_editor)
            except:
                try:
                    network_widget = network_editor.widget()
                except:
                    pass
            
            if not network_widget:
                self.log("Could not find network editor widget (try focusing a network editor)")
                return False
            
            if hasattr(network_widget, '_ase_drop_handler_installed'):
                self.log("Drop handler already installed")
                return True
            
            class DropFilter(QtCore.QObject):
                def eventFilter(self, obj, event):
                    if event.type() == QtCore.QEvent.DragEnter:
                        if event.mimeData().hasText():
                            event.acceptProposedAction()
                            return True
                    
                    if event.type() == QtCore.QEvent.Drop:
                        if event.mimeData().hasText():
                            color_data = event.mimeData().text()
                            if ',' in color_data:
                                self.create_color_node(network_editor, color_data)
                                return True
                    
                    return False
            
            drop_filter = DropFilter()
            network_widget.installEventFilter(drop_filter)
            network_widget._ase_drop_handler_installed = True
            self.log("Drop handler successfully installed")
            return True
            
        except Exception as e:
            error_msg = f"Error setting up drop handler: {str(e)}"
            self.status_bar.setText(error_msg)
            self.log(f"ERROR: {error_msg}")
            return False

    def load_ase_file(self):
        """Load and parse an ASE file with enhanced error checking"""
        self.clear_swatches()
        self.log("\n=== Starting ASE File Load ===")
        
        filepath = hou.ui.selectFile(
            title="Select ASE File",
            pattern="*.ase",
            file_type=hou.fileType.Any)
            
        if not filepath:
            self.status_bar.setText("No file selected")
            self.log("File selection canceled by user")
            return
            
        filepath = hou.text.expandString(filepath)
        filepath = os.path.normpath(filepath)
        self.log(f"Selected file: {filepath}")
        
        if not os.path.exists(filepath):
            error_msg = f"File not found: {filepath}"
            self.status_bar.setText(error_msg)
            self.log(error_msg)
            return
            
        file_size = os.path.getsize(filepath)
        if file_size < 12:  # Minimum size for ASE header
            error_msg = f"File too small ({file_size} bytes) to be a valid ASE file"
            self.status_bar.setText(error_msg)
            self.log(error_msg)
            return
            
        self.file_path.setText(filepath)
        self.status_bar.setText("Loading swatches...")
        self.log(f"Beginning file parsing...")
        QtWidgets.QApplication.processEvents()
        
        try:
            with open(filepath, 'rb') as f:
                # Read and verify header
                header = f.read(12)
                if len(header) != 12:
                    error_msg = "Invalid ASE file (header incomplete)"
                    raise ValueError(error_msg)
                    
                signature, version_major, version_minor, num_blocks = struct.unpack('>4sHHH', header[:10])
                self.log(f"File header: Signature={signature}, Version={version_major}.{version_minor}, Blocks={num_blocks}")
                
                if signature != b'ASEF':
                    error_msg = f"Not a valid ASE file (invalid signature: {signature})"
                    raise ValueError(error_msg)
                
                if num_blocks == 0:
                    self.log("Warning: ASE file contains 0 color blocks (may be empty)")
                    self.status_bar.setText("ASE file contains no color swatches")
                    return
                
                current_group = None
                swatches = []
                rgb_count = 0
                cmyk_count = 0
                other_count = 0
                
                for block_idx in range(num_blocks):
                    block_header = f.read(8)
                    if len(block_header) != 8:
                        self.log(f"Warning: Block {block_idx+1} header incomplete")
                        break
                        
                    block_type, block_length = struct.unpack('>II', block_header)
                    self.log(f"Block {block_idx+1}: Type=0x{block_type:08X}, Length={block_length} bytes")
                    
                    # Color group block
                    if block_type == 0xC001:
                        name_len = struct.unpack('>H', f.read(2))[0]
                        name_bytes = f.read(name_len * 2)
                        current_group = name_bytes.decode('utf-16be').rstrip('\x00')
                        remaining = block_length - 2 - (name_len * 2)
                        if remaining > 0:
                            f.read(remaining)
                        self.log(f"  Group: '{current_group}'")
                    
                    # Color entry block
                    elif block_type == 0x0001:
                        name_len = struct.unpack('>H', f.read(2))[0]
                        name_bytes = f.read(name_len * 2)
                        name = name_bytes.decode('utf-16be').rstrip('\x00')
                        self.log(f"  Swatch: '{name}'")
                        
                        color_model = f.read(4).decode('ascii')
                        self.log(f"  Color model: {color_model}")
                        
                        if color_model == 'RGB ':
                            rgb_data = f.read(12)
                            if len(rgb_data) != 12:
                                self.log("  Warning: RGB data incomplete")
                                break
                                
                            r, g, b = struct.unpack('>3I', rgb_data)
                            r /= 65535.0
                            g /= 65535.0
                            b /= 65535.0
                            
                            f.read(2)  # Skip color type
                            
                            swatches.append({
                                'name': name,
                                'color': (r, g, b),
                                'group': current_group,
                                'model': 'RGB'
                            })
                            rgb_count += 1
                            self.log(f"  RGB values: {r:.3f}, {g:.3f}, {b:.3f}")
                        
                        elif color_model == 'CMYK':
                            cmyk_data = f.read(16)
                            if len(cmyk_data) != 16:
                                self.log("  Warning: CMYK data incomplete")
                                break
                                
                            c, m, y, k = struct.unpack('>4I', cmyk_data)
                            c /= 65535.0
                            m /= 65535.0
                            y /= 65535.0
                            k /= 65535.0
                            
                            # Convert CMYK to RGB
                            r, g, b = cmyk_to_rgb(c, m, y, k)
                            
                            f.read(2)  # Skip color type
                            
                            swatches.append({
                                'name': f"{name} (CMYK)",
                                'color': (r, g, b),
                                'group': current_group,
                                'model': 'CMYK',
                                'cmyk': (c, m, y, k)
                            })
                            cmyk_count += 1
                            self.log(f"  CMYK values: {c:.3f}, {m:.3f}, {y:.3f}, {k:.3f} â RGB: {r:.3f}, {g:.3f}, {b:.3f}")
                        
                        else:
                            remaining = block_length - 6 - (name_len * 2)
                            if remaining > 0:
                                f.read(remaining)
                            other_count += 1
                            self.log(f"  Unsupported color model: {color_model}")
                    
                    else:
                        if block_length > 0:
                            f.read(block_length)
                        self.log(f"  Unknown block type: 0x{block_type:08X}")
                
                if not swatches:
                    self.status_bar.setText(f"File loaded but no supported colors found")
                    self.log("No supported color swatches found in file")
                    return
                
                self.swatches = swatches
                self.display_swatches()
                
                # Show conversion stats
                status_msg = f"Loaded {len(swatches)} swatches ({rgb_count} RGB, {cmyk_count} CMYK) from {os.path.basename(filepath)}"
                if other_count > 0:
                    status_msg += f" (skipped {other_count} unsupported)"
                self.status_bar.setText(status_msg)
                self.log(f"=== File loading complete ===")
                self.log(f"Total swatches: {len(swatches)}")
                self.log(f"RGB swatches: {rgb_count}")
                self.log(f"CMYK swatches: {cmyk_count}")
                if other_count > 0:
                    self.log(f"Unsupported color models: {other_count}")
                
        except Exception as e:
            error_msg = f"Error loading ASE file: {str(e)}"
            self.status_bar.setText(error_msg)
            self.log(f"ERROR: {error_msg}")
            hou.ui.displayMessage(error_msg)

    def clear_swatches(self):
        """Clear all swatches from display"""
        while self.swatch_layout.count():
            item = self.swatch_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        self.swatches = []
        self.log("Cleared all swatches from display")
    
    def display_swatches(self):
        """Display all loaded swatches"""
        self.clear_swatches()
        self.log(f"Displaying {len(self.swatches)} swatches...")
        
        grouped_swatches = {}
        for swatch in self.swatches:
            group_name = swatch['group'] or "Ungrouped"
            if group_name not in grouped_swatches:
                grouped_swatches[group_name] = []
            grouped_swatches[group_name].append(swatch)
        
        for group_name, group_swatches in grouped_swatches.items():
            group_label = QtWidgets.QLabel(f"<b>{group_name}</b>")
            group_label.setStyleSheet("font-size: 14px; margin-top: 10px;")
            self.swatch_layout.addWidget(group_label)
            
            for swatch in group_swatches:
                swatch_widget = self.create_swatch_widget(swatch)
                self.swatch_layout.addWidget(swatch_widget)
        
        self.log(f"Finished displaying swatches")
    
    def create_swatch_widget(self, swatch):
        widget = QtWidgets.QWidget()
        widget.setFixedSize(120, 120)
        
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(2, 2, 2, 2)
        widget.setLayout(layout)
        
        # Color preview
        color_widget = QtWidgets.QWidget()
        color_widget.setFixedHeight(80)
        
        # Enhanced tooltip with color info
        tooltip = f"{swatch['name']}\n"
        if swatch.get('model') == 'CMYK':
            c, m, y, k = swatch['cmyk']
            tooltip += (
                f"CMYK: {c:.2f}, {m:.2f}, {y:.2f}, {k:.2f}\n"
                f"â RGB: {swatch['color'][0]:.3f}, {swatch['color'][1]:.3f}, {swatch['color'][2]:.3f}"
            )
        else:
            tooltip += f"RGB: {swatch['color'][0]:.3f}, {swatch['color'][1]:.3f}, {swatch['color'][2]:.3f}"
        
        tooltip += f"\nGroup: {swatch['group'] or 'Ungrouped'}"
        color_widget.setToolTip(tooltip)
        
        # Drag handling
        color_widget.mousePressEvent = lambda e: self.start_swatch_drag(swatch, color_widget, e)
        color_widget.mouseMoveEvent = lambda e: self.drag_swatch(swatch, color_widget, e)
        
        layout.addWidget(color_widget)
        
        # Color model label
        model_label = QtWidgets.QLabel(swatch.get('model', 'RGB'))
        model_label.setAlignment(QtCore.Qt.AlignCenter)
        model_label.setStyleSheet("font-size: 9px; font-weight: bold;")
        layout.addWidget(model_label)
        
        # Name label
        name_label = QtWidgets.QLabel(swatch['name'])
        name_label.setAlignment(QtCore.Qt.AlignCenter)
        name_label.setStyleSheet("font-size: 10px;")
        name_label.setWordWrap(True)
        layout.addWidget(name_label)
        
        # Set color
        r, g, b = swatch['color']
        color = QtGui.QColor(int(r*255), int(g*255), int(b*255))
        palette = color_widget.palette()
        palette.setColor(QtGui.QPalette.Window, color)
        color_widget.setAutoFillBackground(True)
        color_widget.setPalette(palette)
        
        # Set text color based on brightness
        brightness = (r*255)*0.299 + (g*255)*0.587 + (b*255)*0.114
        text_color = "black" if brightness > 128 else "white"
        name_label.setStyleSheet(f"color: {text_color}; font-size: 10px;")
        model_label.setStyleSheet(f"color: {text_color}; font-size: 9px; font-weight: bold;")
        
        return widget
    
    def start_swatch_drag(self, swatch, widget, event):
        if event.button() == QtCore.Qt.LeftButton:
            widget.drag_start_pos = event.pos()
            self.log(f"Started drag for swatch: {swatch['name']}")
    
    def drag_swatch(self, swatch, widget, event):
        if not (event.buttons() & QtCore.Qt.LeftButton):
            return
        if (event.pos() - widget.drag_start_pos).manhattanLength() < QtWidgets.QApplication.startDragDistance():
            return
        
        drag = QtGui.QDrag(widget)
        mime_data = QtCore.QMimeData()
        
        r, g, b = swatch['color']
        mime_data.setText(f"{r:.4f},{g:.4f},{b:.4f}")
        drag.setMimeData(mime_data)
        
        pixmap = QtGui.QPixmap(widget.size())
        widget.render(pixmap)
        drag.setPixmap(pixmap)
        drag.setHotSpot(event.pos())
        
        self.log(f"Dragging swatch: {swatch['name']} (RGB: {r:.3f}, {g:.3f}, {b:.3f})")
        drag.exec_(QtCore.Qt.CopyAction)
    
    def create_color_node(self, network_editor, color_data):
        """Create a color node from dropped swatch"""
        try:
            self.log(f"Creating color node from drop: {color_data}")
            network_widget = None
            
            # Try multiple ways to find the widget
            try:
                network_widget = hou.qt.floatingPanelWidget(network_editor)
            except:
                try:
                    network_widget = network_editor.widget()
                except:
                    pass
            
            if not network_widget:
                self.log("Could not find network editor widget for drop")
                return
                
            cursor_pos = QtGui.QCursor.pos()
            local_pos = network_widget.mapFromGlobal(cursor_pos)
            scene_pos = network_widget.mapToScene(local_pos)
            
            parent = network_editor.pwd()
            color_node = parent.createNode("color")
            color_node.setPosition((scene_pos.x(), scene_pos.y()))
            
            r, g, b = map(float, color_data.split(','))
            color_node.parmTuple("color").set((r, g, b))
            
            color_name = f"color_{int(r*255)}_{int(g*255)}_{int(b*255)}"
            color_node.setName(color_name, unique_name=True)
            
            success_msg = f"Created color node: {color_name} at ({scene_pos.x():.1f}, {scene_pos.y():.1f})"
            self.status_bar.setText(success_msg)
            self.log(success_msg)
            
        except Exception as e:
            error_msg = f"Error creating node: {str(e)}"
            self.status_bar.setText(error_msg)
            self.log(f"ERROR: {error_msg}")

def showAseSwatchLoader():
    global ase_swatch_loader
    try:
        ase_swatch_loader.close()
    except:
        pass
    ase_swatch_loader = AseSwatchLoader()

showAseSwatchLoader()]]></script>
  </tool>

  <tool name="Import Files" label="Import Files" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os

directory_string = hou.ui.selectFile(file_type=hou.fileType.Directory)
directory = hou.expandString(directory_string)
#print(directory)
contrainer = hou.node('/obj').createNode('subnet')
contrainer.setName("import", unique_name=True)
valid_extensions = (".fbx", ".obj", ".abc")

list = os.listdir(directory)
for file in list:
    if file.endswith(valid_extensions):
        node = contrainer.createNode('geo')
        node.setName(file)
        t = node.createNode('file')
        t.parm('file').set(os.path.join(directory, file))
        t.setHardLocked(True)
        
        #print file]]></script>
  </tool>

  <tool name="Export Rops" label="Export Rops" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import shelf_export_rops # your saved module filename without .py
shelf_export_rops.show_ui()]]></script>
  </tool>
</shelfDocument>
