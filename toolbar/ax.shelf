<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="AX" label="AX">
    <memberTool name="create octane rop"/>
    <memberTool name="create rop for bake"/>
    <memberTool name="Create Instance"/>
    <memberTool name="Delete Materials0"/>
    <memberTool name="Delete UVs"/>
    <memberTool name="UV/NO UV"/>
    <memberTool name="Unlock File"/>
    <memberTool name="Import Files"/>
    <memberTool name="Hierarchy for Octane"/>
    <memberTool name="Merge selected nodes to network"/>
    <memberTool name="Arnold UDIM"/>
    <memberTool name="Create RS Arnold Material"/>
    <memberTool name="Create Octane Arnold Material"/>
    <memberTool name="Split SOP by shop_materialpath"/>
    <memberTool name="createNull"/>
    <memberTool name="Swatches"/>
    <memberTool name="Export Rops"/>
    <memberTool name="Copernicus Heightmap Layers Export"/>
    <memberTool name="Relink Files"/>
    <memberTool name="Loop Sequence"/>
    <memberTool name="Asset Manager"/>
  </toolshelf>

  <tool name="GSG Octane Material" label="GSG Octane Material" icon="custom_hda_icon">
    <script scriptType="python"><![CDATA[import soptoolutils

node = soptoolutils.genericTool(kwargs, 'AX_OctaneQuickMaterial', exact_node_type=False)
node.parm('presets').set(1)
]]></script>
  </tool>

  <tool name="Solaris Material Library Fill" label="Solaris Material Library Fill" icon="custom_hda_icon">
    <script scriptType="python"><![CDATA[import hou

node = hou.selectedNodes()[0]
pane = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
cursor_position = pane.cursorPosition()

print(node)]]></script>
  </tool>

  <tool name="Swatches" label="Swatches" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import struct
from PySide6 import QtWidgets, QtGui, QtCore

def cmyk_to_rgb(c, m, y, k):
    r = 1.0 - min(1.0, c * (1 - k) + k)
    g = 1.0 - min(1.0, m * (1 - k) + k)
    b = 1.0 - min(1.0, y * (1 - k) + k)
    return (r, g, b)

class SwatchLabel(QtWidgets.QLabel):
    selected_labels = set()

    def __init__(self, name, rgb, parent=None):
        super().__init__(parent)
        self.name = name
        self.rgb = rgb
        self.setFixedSize(60, 60)
        r, g, b = [int(c * 255) for c in rgb]
        self.setStyleSheet(f"background-color: rgb({r},{g},{b}); border: 1px solid black;")
        self.setToolTip(f"{name}\nRGB: {rgb}")
        self.setCursor(QtCore.Qt.OpenHandCursor)
        self._drag_active = False
        self._selected = False

    def set_selected(self, selected):
        self._selected = selected
        border = "3px solid #33AADD" if self._selected else "1px solid black"
        r, g, b = [int(c * 255) for c in self.rgb]
        self.setStyleSheet(f"background-color: rgb({r},{g},{b}); border: {border};")

    def mousePressEvent(self, event):
        if event.button() != QtCore.Qt.LeftButton:
            return

        modifiers = QtWidgets.QApplication.keyboardModifiers()
        if modifiers in [QtCore.Qt.ControlModifier, QtCore.Qt.ShiftModifier]:
            # Toggle selection
            self.set_selected(not self._selected)
            if self._selected:
                SwatchLabel.selected_labels.add(self)
            else:
                SwatchLabel.selected_labels.discard(self)
        else:
            # Clear all others
            for label in list(SwatchLabel.selected_labels):
                label.set_selected(False)
            self.set_selected(True)
            SwatchLabel.selected_labels = {self}

        self._drag_active = True
        self._start_pos = event.pos()

    def mouseMoveEvent(self, event):
        if self._drag_active and (event.pos() - self._start_pos).manhattanLength() > 5:
            self.setCursor(QtCore.Qt.ClosedHandCursor)

    def mouseReleaseEvent(self, event):
        self.setCursor(QtCore.Qt.OpenHandCursor)
        if not self._drag_active:
            return
        self._drag_active = False

        pane = hou.ui.paneTabUnderCursor()
        if not isinstance(pane, hou.NetworkEditor):
            return  # Not over a network editor

        network = pane.pwd()
        pos = pane.cursorPosition()
        selected = list(SwatchLabel.selected_labels or {self})

        spacing = hou.Vector2(1.5, -1.5)
        base_pos = pos - hou.Vector2(len(selected) / 2.0, 0.0)

        try:
            created = []
            for i, swatch in enumerate(selected):
                node = network.createNode("color")
                node.parmTuple("color").set(swatch.rgb)
                node.setPosition(base_pos + spacing * i)
                created.append(node)

            for a, b in zip(created[:-1], created[1:]):
                b.setNextInput(a)

            if created:
                created[-1].setSelected(True, clear_all_selected=True)
                pane.setCurrentNode(created[-1])
        except Exception as e:
            hou.ui.displayMessage(f"Error creating color node(s): {e}")


class SwatchViewer(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ASE Swatch Viewer")
        self.setMinimumSize(500, 400)

        layout = QtWidgets.QVBoxLayout(self)
        self.setLayout(layout)

        self.load_btn = QtWidgets.QPushButton("Load .ASE File")
        self.load_btn.clicked.connect(self.load_ase)
        layout.addWidget(self.load_btn)

        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        layout.addWidget(self.scroll_area)

        self.container = QtWidgets.QWidget()
        self.grid = QtWidgets.QGridLayout(self.container)
        self.grid.setSpacing(6)
        self.scroll_area.setWidget(self.container)

        self.console = QtWidgets.QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setMaximumHeight(100)
        self.console.setStyleSheet("background-color: #111; color: #eee; font-family: Consolas; font-size: 11px;")
        layout.addWidget(self.console)

    def log(self, message):
        self.console.appendPlainText(str(message))

    def closeEvent(self, event):
        if hasattr(hou.session, "swatch_viewer"):
            hou.session.swatch_viewer = None
        event.accept()

    def clear_grid(self):
        while self.grid.count():
            item = self.grid.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        # Clear selection set on reload
        SwatchLabel.selected_labels.clear()

    def load_ase(self):
        filepath, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select ASE File", filter="*.ase")
        if not filepath:
            self.log("No file selected.")
            return

        self.log(f"Loading ASE: {filepath}")
        self.clear_grid()
        swatches = self.parse_ase(filepath)

        row = col = 0
        for name, rgb in swatches:
            label = SwatchLabel(name, rgb)
            self.grid.addWidget(label, row, col)
            col += 1
            if col >= 6:
                col = 0
                row += 1
        self.log(f"Loaded {len(swatches)} swatches.")

    def parse_ase(self, path):
        try:
            with open(path, "rb") as f:
                data = f.read()
        except Exception as e:
            self.log(f"Error reading file: {e}")
            return []

        swatches = []
        pos = 0

        def read_u16():
            nonlocal pos
            val = struct.unpack(">H", data[pos:pos+2])[0]
            pos += 2
            return val

        def read_u32():
            nonlocal pos
            val = struct.unpack(">I", data[pos:pos+4])[0]
            pos += 4
            return val

        def read_f32():
            nonlocal pos
            val = struct.unpack(">f", data[pos:pos+4])[0]
            pos += 4
            return val

        def read_utf16():
            nonlocal pos
            strlen = read_u16()
            raw = data[pos:pos + strlen * 2]
            pos += strlen * 2
            return raw.decode('utf_16_be').rstrip('\0')

        if data[0:4] != b"ASEF":
            self.log("Invalid ASE file header.")
            return []
        
        pos = 4
        major = read_u16()
        minor = read_u16()
        block_count = read_u32()
        self.log(f"ASE version: {major}.{minor}")
        self.log(f"ASE block count: {block_count}")

        block_index = 0

        while pos < len(data):
            try:
                block_type = read_u16()
                block_len = read_u32()
                block_end = pos + block_len
                block_index += 1

                if block_type == 0x0001:  # Color entry
                    name = read_utf16()
                    color_model = data[pos:pos+4].decode("ascii").strip()
                    pos += 4

                    if color_model == "RGB":
                        r = read_f32()
                        g = read_f32()
                        b = read_f32()
                        swatches.append((name, (r, g, b)))
                        self.log(f"RGB swatch: {name} â ({r:.2f}, {g:.2f}, {b:.2f})")
                    elif color_model == "CMYK":
                        c = read_f32()
                        m = read_f32()
                        y = read_f32()
                        k = read_f32()
                        r, g, b = cmyk_to_rgb(c, m, y, k)
                        swatches.append((name + " (CMYK)", (r, g, b)))
                        self.log(f"CMYK swatch: {name} â ({r:.2f}, {g:.2f}, {b:.2f})")
                    else:
                        self.log(f"Unsupported color model: {color_model}")

                    pos += 2  # skip color type
                else:
                    self.log(f"Skipping block type: {hex(block_type)}")

                pos = block_end
            except Exception as e:
                self.log(f"Error parsing block {block_index}: {e}")
                break

        return swatches

def launch_swatch_viewer():
    if not hasattr(hou.session, "swatch_viewer") or not isinstance(hou.session.swatch_viewer, QtWidgets.QWidget):
        hou.session.swatch_viewer = SwatchViewer()
    if hou.session.swatch_viewer is not None:
        hou.session.swatch_viewer.show()
        hou.session.swatch_viewer.raise_()

launch_swatch_viewer()
]]></script>
  </tool>

  <tool name="tool_1" label="New Tool" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os
import struct
import time
from PySide2 import QtWidgets, QtGui, QtCore

def cmyk_to_rgb(c, m, y, k):
    """Convert CMYK values (0-1 range) to RGB (0-1 range)"""
    r = (1.0 - c) * (1.0 - k)
    g = (1.0 - m) * (1.0 - k)
    b = (1.0 - y) * (1.0 - k)
    return (r, g, b)

class FlowLayout(QtWidgets.QLayout):
    """Custom flow layout that arranges widgets left-to-right and wraps as needed"""
    def __init__(self, parent=None, margin=0, spacing=5):
        super(FlowLayout, self).__init__(parent)
        self.setSpacing(spacing)
        if parent is not None:
            self.setContentsMargins(margin, margin, margin, margin)
        self.item_list = []

    def addItem(self, item):
        self.item_list.append(item)

    def count(self):
        return len(self.item_list)

    def itemAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list.pop(index)
        return None

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        return self.do_layout(QtCore.QRect(0, 0, width, 0), True)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QtCore.QSize()
        for item in self.item_list:
            size = size.expandedTo(item.minimumSize())
        margins = self.contentsMargins()
        size += QtCore.QSize(margins.left() + margins.right(), margins.top() + margins.bottom())
        return size

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.do_layout(rect, False)

    def do_layout(self, rect, test_only):
        x = rect.x()
        y = rect.y()
        line_height = 0
        
        for item in self.item_list:
            wid = item.widget()
            space_x = self.spacing()
            space_y = self.spacing()
            next_x = x + item.sizeHint().width() + space_x
            if next_x - space_x > rect.right() and line_height > 0:
                x = rect.x()
                y = y + line_height + space_y
                next_x = x + item.sizeHint().width() + space_x
                line_height = 0
            
            if not test_only:
                item.setGeometry(QtCore.QRect(QtCore.QPoint(x, y), item.sizeHint()))
            
            x = next_x
            line_height = max(line_height, item.sizeHint().height())
        
        return y + line_height - rect.y()

class DebugConsole(QtWidgets.QPlainTextEdit):
    """Custom console widget for debug output"""
    def __init__(self, parent=None):
        super(DebugConsole, self).__init__(parent)
        self.setReadOnly(True)
        self.setStyleSheet("""
            QPlainTextEdit {
                background-color: #222;
                color: #ddd;
                font-family: Consolas, monospace;
                font-size: 10px;
            }
        """)
        self.setMaximumHeight(150)
    
    def log(self, message, color=None):
        timestamp = time.strftime("%H:%M:%S", time.localtime())
        msg = f"[{timestamp}] {message}"
        self.appendPlainText(msg)
        self.verticalScrollBar().setValue(self.verticalScrollBar().maximum())

class AseSwatchLoader(QtWidgets.QWidget):
    def __init__(self):
        super(AseSwatchLoader, self).__init__()
        self.setWindowTitle("ASE Swatch Loader")
        self.setMinimumSize(800, 600)
        self.swatches = []
        
        # Main layout
        self.layout = QtWidgets.QVBoxLayout()
        self.setLayout(self.layout)
        
        # File selection area
        self.file_layout = QtWidgets.QHBoxLayout()
        self.file_path = QtWidgets.QLineEdit()
        self.file_path.setReadOnly(True)
        self.file_path.setPlaceholderText("No ASE file selected")
        self.browse_btn = QtWidgets.QPushButton("Browse...")
        self.browse_btn.clicked.connect(self.load_ase_file)
        self.file_layout.addWidget(self.file_path)
        self.file_layout.addWidget(self.browse_btn)
        self.layout.addLayout(self.file_layout)
        
        # Swatch display area
        self.swatch_area = QtWidgets.QScrollArea()
        self.swatch_area.setWidgetResizable(True)
        self.swatch_container = QtWidgets.QWidget()
        self.swatch_layout = FlowLayout()
        self.swatch_container.setLayout(self.swatch_layout)
        self.swatch_area.setWidget(self.swatch_container)
        self.layout.addWidget(self.swatch_area)
        
        # Debug console
        self.debug_console = DebugConsole()
        self.console_button = QtWidgets.QPushButton("Toggle Console")
        self.console_button.setCheckable(True)
        self.console_button.setChecked(False)
        self.console_button.toggled.connect(self.toggle_console)
        self.debug_console.setVisible(False)
        
        # Status bar
        self.status_layout = QtWidgets.QHBoxLayout()
        self.status_bar = QtWidgets.QLabel("Ready")
        self.status_bar.setAlignment(QtCore.Qt.AlignLeft)
        
        self.status_layout.addWidget(self.status_bar)
        self.status_layout.addWidget(self.console_button)
        self.layout.addLayout(self.status_layout)
        self.layout.addWidget(self.debug_console)
        
        # Setup network editor drop handler
        self.drop_handler_installed = False
        self.install_drop_handler_timer = QtCore.QTimer()
        self.install_drop_handler_timer.timeout.connect(self.try_setup_drop_handler)
        self.install_drop_handler_timer.start(1000)  # Try every second until found
        
        # Make window float in Houdini
        self.setParent(hou.qt.mainWindow(), QtCore.Qt.Window)
        self.show()
    
    def toggle_console(self, visible):
        self.debug_console.setVisible(visible)
        if visible:
            self.console_button.setText("Hide Console")
        else:
            self.console_button.setText("Show Console")
    
    def log(self, message):
        """Log message to debug console"""
        self.debug_console.log(message)
        print(message)  # Also print to Houdini console
    
    def try_setup_drop_handler(self):
        """Try to setup drop handler until network editor is available"""
        if not self.drop_handler_installed:
            if self.setup_drop_handler():
                self.install_drop_handler_timer.stop()
                self.drop_handler_installed = True
    
    def setup_drop_handler(self):
        """Setup network editor to accept color drops"""
        try:
            self.log("Setting up network editor drop handler...")
            
            # Get all network editors in the current desktop
            network_editors = [pane for pane in hou.ui.curDesktop().paneTabs() 
                             if pane.type() == hou.paneTabType.NetworkEditor]
            
            if not network_editors:
                self.log("No network editor found (try opening a network editor pane)")
                return False
            
            # Use the first available network editor
            network_editor = network_editors[0]
            network_widget = None
            
            # Try multiple ways to find the widget
            try:
                network_widget = hou.qt.floatingPanelWidget(network_editor)
            except:
                try:
                    network_widget = network_editor.widget()
                except:
                    pass
            
            if not network_widget:
                self.log("Could not find network editor widget (try focusing a network editor)")
                return False
            
            if hasattr(network_widget, '_ase_drop_handler_installed'):
                self.log("Drop handler already installed")
                return True
            
            class DropFilter(QtCore.QObject):
                def eventFilter(self, obj, event):
                    if event.type() == QtCore.QEvent.DragEnter:
                        if event.mimeData().hasText():
                            event.acceptProposedAction()
                            return True
                    
                    if event.type() == QtCore.QEvent.Drop:
                        if event.mimeData().hasText():
                            color_data = event.mimeData().text()
                            if ',' in color_data:
                                self.create_color_node(network_editor, color_data)
                                return True
                    
                    return False
            
            drop_filter = DropFilter()
            network_widget.installEventFilter(drop_filter)
            network_widget._ase_drop_handler_installed = True
            self.log("Drop handler successfully installed")
            return True
            
        except Exception as e:
            error_msg = f"Error setting up drop handler: {str(e)}"
            self.status_bar.setText(error_msg)
            self.log(f"ERROR: {error_msg}")
            return False

    def load_ase_file(self):
        """Load and parse an ASE file with enhanced error checking"""
        self.clear_swatches()
        self.log("\n=== Starting ASE File Load ===")
        
        filepath = hou.ui.selectFile(
            title="Select ASE File",
            pattern="*.ase",
            file_type=hou.fileType.Any)
            
        if not filepath:
            self.status_bar.setText("No file selected")
            self.log("File selection canceled by user")
            return
            
        filepath = hou.text.expandString(filepath)
        filepath = os.path.normpath(filepath)
        self.log(f"Selected file: {filepath}")
        
        if not os.path.exists(filepath):
            error_msg = f"File not found: {filepath}"
            self.status_bar.setText(error_msg)
            self.log(error_msg)
            return
            
        file_size = os.path.getsize(filepath)
        if file_size < 12:  # Minimum size for ASE header
            error_msg = f"File too small ({file_size} bytes) to be a valid ASE file"
            self.status_bar.setText(error_msg)
            self.log(error_msg)
            return
            
        self.file_path.setText(filepath)
        self.status_bar.setText("Loading swatches...")
        self.log(f"Beginning file parsing...")
        QtWidgets.QApplication.processEvents()
        
        try:
            with open(filepath, 'rb') as f:
                # Read and verify header
                header = f.read(12)
                if len(header) != 12:
                    error_msg = "Invalid ASE file (header incomplete)"
                    raise ValueError(error_msg)
                    
                signature, version_major, version_minor, num_blocks = struct.unpack('>4sHHH', header[:10])
                self.log(f"File header: Signature={signature}, Version={version_major}.{version_minor}, Blocks={num_blocks}")
                
                if signature != b'ASEF':
                    error_msg = f"Not a valid ASE file (invalid signature: {signature})"
                    raise ValueError(error_msg)
                
                if num_blocks == 0:
                    self.log("Warning: ASE file contains 0 color blocks (may be empty)")
                    self.status_bar.setText("ASE file contains no color swatches")
                    return
                
                current_group = None
                swatches = []
                rgb_count = 0
                cmyk_count = 0
                other_count = 0
                
                for block_idx in range(num_blocks):
                    block_header = f.read(8)
                    if len(block_header) != 8:
                        self.log(f"Warning: Block {block_idx+1} header incomplete")
                        break
                        
                    block_type, block_length = struct.unpack('>II', block_header)
                    self.log(f"Block {block_idx+1}: Type=0x{block_type:08X}, Length={block_length} bytes")
                    
                    # Color group block
                    if block_type == 0xC001:
                        name_len = struct.unpack('>H', f.read(2))[0]
                        name_bytes = f.read(name_len * 2)
                        current_group = name_bytes.decode('utf-16be').rstrip('\x00')
                        remaining = block_length - 2 - (name_len * 2)
                        if remaining > 0:
                            f.read(remaining)
                        self.log(f"  Group: '{current_group}'")
                    
                    # Color entry block
                    elif block_type == 0x0001:
                        name_len = struct.unpack('>H', f.read(2))[0]
                        name_bytes = f.read(name_len * 2)
                        name = name_bytes.decode('utf-16be').rstrip('\x00')
                        self.log(f"  Swatch: '{name}'")
                        
                        color_model = f.read(4).decode('ascii')
                        self.log(f"  Color model: {color_model}")
                        
                        if color_model == 'RGB ':
                            rgb_data = f.read(12)
                            if len(rgb_data) != 12:
                                self.log("  Warning: RGB data incomplete")
                                break
                                
                            r, g, b = struct.unpack('>3I', rgb_data)
                            r /= 65535.0
                            g /= 65535.0
                            b /= 65535.0
                            
                            f.read(2)  # Skip color type
                            
                            swatches.append({
                                'name': name,
                                'color': (r, g, b),
                                'group': current_group,
                                'model': 'RGB'
                            })
                            rgb_count += 1
                            self.log(f"  RGB values: {r:.3f}, {g:.3f}, {b:.3f}")
                        
                        elif color_model == 'CMYK':
                            cmyk_data = f.read(16)
                            if len(cmyk_data) != 16:
                                self.log("  Warning: CMYK data incomplete")
                                break
                                
                            c, m, y, k = struct.unpack('>4I', cmyk_data)
                            c /= 65535.0
                            m /= 65535.0
                            y /= 65535.0
                            k /= 65535.0
                            
                            # Convert CMYK to RGB
                            r, g, b = cmyk_to_rgb(c, m, y, k)
                            
                            f.read(2)  # Skip color type
                            
                            swatches.append({
                                'name': f"{name} (CMYK)",
                                'color': (r, g, b),
                                'group': current_group,
                                'model': 'CMYK',
                                'cmyk': (c, m, y, k)
                            })
                            cmyk_count += 1
                            self.log(f"  CMYK values: {c:.3f}, {m:.3f}, {y:.3f}, {k:.3f} â RGB: {r:.3f}, {g:.3f}, {b:.3f}")
                        
                        else:
                            remaining = block_length - 6 - (name_len * 2)
                            if remaining > 0:
                                f.read(remaining)
                            other_count += 1
                            self.log(f"  Unsupported color model: {color_model}")
                    
                    else:
                        if block_length > 0:
                            f.read(block_length)
                        self.log(f"  Unknown block type: 0x{block_type:08X}")
                
                if not swatches:
                    self.status_bar.setText(f"File loaded but no supported colors found")
                    self.log("No supported color swatches found in file")
                    return
                
                self.swatches = swatches
                self.display_swatches()
                
                # Show conversion stats
                status_msg = f"Loaded {len(swatches)} swatches ({rgb_count} RGB, {cmyk_count} CMYK) from {os.path.basename(filepath)}"
                if other_count > 0:
                    status_msg += f" (skipped {other_count} unsupported)"
                self.status_bar.setText(status_msg)
                self.log(f"=== File loading complete ===")
                self.log(f"Total swatches: {len(swatches)}")
                self.log(f"RGB swatches: {rgb_count}")
                self.log(f"CMYK swatches: {cmyk_count}")
                if other_count > 0:
                    self.log(f"Unsupported color models: {other_count}")
                
        except Exception as e:
            error_msg = f"Error loading ASE file: {str(e)}"
            self.status_bar.setText(error_msg)
            self.log(f"ERROR: {error_msg}")
            hou.ui.displayMessage(error_msg)

    def clear_swatches(self):
        """Clear all swatches from display"""
        while self.swatch_layout.count():
            item = self.swatch_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        self.swatches = []
        self.log("Cleared all swatches from display")
    
    def display_swatches(self):
        """Display all loaded swatches"""
        self.clear_swatches()
        self.log(f"Displaying {len(self.swatches)} swatches...")
        
        grouped_swatches = {}
        for swatch in self.swatches:
            group_name = swatch['group'] or "Ungrouped"
            if group_name not in grouped_swatches:
                grouped_swatches[group_name] = []
            grouped_swatches[group_name].append(swatch)
        
        for group_name, group_swatches in grouped_swatches.items():
            group_label = QtWidgets.QLabel(f"<b>{group_name}</b>")
            group_label.setStyleSheet("font-size: 14px; margin-top: 10px;")
            self.swatch_layout.addWidget(group_label)
            
            for swatch in group_swatches:
                swatch_widget = self.create_swatch_widget(swatch)
                self.swatch_layout.addWidget(swatch_widget)
        
        self.log(f"Finished displaying swatches")
    
    def create_swatch_widget(self, swatch):
        widget = QtWidgets.QWidget()
        widget.setFixedSize(120, 120)
        
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(2, 2, 2, 2)
        widget.setLayout(layout)
        
        # Color preview
        color_widget = QtWidgets.QWidget()
        color_widget.setFixedHeight(80)
        
        # Enhanced tooltip with color info
        tooltip = f"{swatch['name']}\n"
        if swatch.get('model') == 'CMYK':
            c, m, y, k = swatch['cmyk']
            tooltip += (
                f"CMYK: {c:.2f}, {m:.2f}, {y:.2f}, {k:.2f}\n"
                f"â RGB: {swatch['color'][0]:.3f}, {swatch['color'][1]:.3f}, {swatch['color'][2]:.3f}"
            )
        else:
            tooltip += f"RGB: {swatch['color'][0]:.3f}, {swatch['color'][1]:.3f}, {swatch['color'][2]:.3f}"
        
        tooltip += f"\nGroup: {swatch['group'] or 'Ungrouped'}"
        color_widget.setToolTip(tooltip)
        
        # Drag handling
        color_widget.mousePressEvent = lambda e: self.start_swatch_drag(swatch, color_widget, e)
        color_widget.mouseMoveEvent = lambda e: self.drag_swatch(swatch, color_widget, e)
        
        layout.addWidget(color_widget)
        
        # Color model label
        model_label = QtWidgets.QLabel(swatch.get('model', 'RGB'))
        model_label.setAlignment(QtCore.Qt.AlignCenter)
        model_label.setStyleSheet("font-size: 9px; font-weight: bold;")
        layout.addWidget(model_label)
        
        # Name label
        name_label = QtWidgets.QLabel(swatch['name'])
        name_label.setAlignment(QtCore.Qt.AlignCenter)
        name_label.setStyleSheet("font-size: 10px;")
        name_label.setWordWrap(True)
        layout.addWidget(name_label)
        
        # Set color
        r, g, b = swatch['color']
        color = QtGui.QColor(int(r*255), int(g*255), int(b*255))
        palette = color_widget.palette()
        palette.setColor(QtGui.QPalette.Window, color)
        color_widget.setAutoFillBackground(True)
        color_widget.setPalette(palette)
        
        # Set text color based on brightness
        brightness = (r*255)*0.299 + (g*255)*0.587 + (b*255)*0.114
        text_color = "black" if brightness > 128 else "white"
        name_label.setStyleSheet(f"color: {text_color}; font-size: 10px;")
        model_label.setStyleSheet(f"color: {text_color}; font-size: 9px; font-weight: bold;")
        
        return widget
    
    def start_swatch_drag(self, swatch, widget, event):
        if event.button() == QtCore.Qt.LeftButton:
            widget.drag_start_pos = event.pos()
            self.log(f"Started drag for swatch: {swatch['name']}")
    
    def drag_swatch(self, swatch, widget, event):
        if not (event.buttons() & QtCore.Qt.LeftButton):
            return
        if (event.pos() - widget.drag_start_pos).manhattanLength() < QtWidgets.QApplication.startDragDistance():
            return
        
        drag = QtGui.QDrag(widget)
        mime_data = QtCore.QMimeData()
        
        r, g, b = swatch['color']
        mime_data.setText(f"{r:.4f},{g:.4f},{b:.4f}")
        drag.setMimeData(mime_data)
        
        pixmap = QtGui.QPixmap(widget.size())
        widget.render(pixmap)
        drag.setPixmap(pixmap)
        drag.setHotSpot(event.pos())
        
        self.log(f"Dragging swatch: {swatch['name']} (RGB: {r:.3f}, {g:.3f}, {b:.3f})")
        drag.exec_(QtCore.Qt.CopyAction)
    
    def create_color_node(self, network_editor, color_data):
        """Create a color node from dropped swatch"""
        try:
            self.log(f"Creating color node from drop: {color_data}")
            network_widget = None
            
            # Try multiple ways to find the widget
            try:
                network_widget = hou.qt.floatingPanelWidget(network_editor)
            except:
                try:
                    network_widget = network_editor.widget()
                except:
                    pass
            
            if not network_widget:
                self.log("Could not find network editor widget for drop")
                return
                
            cursor_pos = QtGui.QCursor.pos()
            local_pos = network_widget.mapFromGlobal(cursor_pos)
            scene_pos = network_widget.mapToScene(local_pos)
            
            parent = network_editor.pwd()
            color_node = parent.createNode("color")
            color_node.setPosition((scene_pos.x(), scene_pos.y()))
            
            r, g, b = map(float, color_data.split(','))
            color_node.parmTuple("color").set((r, g, b))
            
            color_name = f"color_{int(r*255)}_{int(g*255)}_{int(b*255)}"
            color_node.setName(color_name, unique_name=True)
            
            success_msg = f"Created color node: {color_name} at ({scene_pos.x():.1f}, {scene_pos.y():.1f})"
            self.status_bar.setText(success_msg)
            self.log(success_msg)
            
        except Exception as e:
            error_msg = f"Error creating node: {str(e)}"
            self.status_bar.setText(error_msg)
            self.log(f"ERROR: {error_msg}")

def showAseSwatchLoader():
    global ase_swatch_loader
    try:
        ase_swatch_loader.close()
    except:
        pass
    ase_swatch_loader = AseSwatchLoader()

showAseSwatchLoader()]]></script>
  </tool>

  <tool name="Import Files" label="Import Files" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os

directory_string = hou.ui.selectFile(file_type=hou.fileType.Directory)
directory = hou.expandString(directory_string)
#print(directory)
contrainer = hou.node('/obj').createNode('subnet')
contrainer.setName("import", unique_name=True)
valid_extensions = (".fbx", ".obj", ".abc")

list = os.listdir(directory)
for file in list:
    if file.endswith(valid_extensions):
        node = contrainer.createNode('geo')
        node.setName(file)
        t = node.createNode('file')
        t.parm('file').set(os.path.join(directory, file))
        t.setHardLocked(True)
        
        #print file]]></script>
  </tool>

  <tool name="Export Rops" label="Export Rops" icon="export_rops">
    <script scriptType="python"><![CDATA[import shelf_export_rops # your saved module filename without .py
shelf_export_rops.show_ui()]]></script>
  </tool>

  <tool name="Copernicus Heightmap Layers Export" label="Copernicus Heightmap Layers Export" icon="export_rops">
    <script scriptType="python"><![CDATA[import hou

# Get the currently selected node.
try:
    selected_node = hou.selectedNodes()[0]
except IndexError:
    hou.ui.displayMessage("Please select a node first.", title="No Node Selected")
    raise SystemExit

# Get the parent network of the selected node.
parent = selected_node.parent()

# Get the position of the selected node to place the new nodes relative to it.
pos = selected_node.position()

# Get all the output labels from the selected node.
output_labels = selected_node.outputLabels()

# Exit if the selected node has no outputs.
if not output_labels:
    hou.ui.displayMessage("The selected node has no outputs.", title="No Outputs Found")
    raise SystemExit

# A list to hold the newly created NULL nodes and their corresponding labels.
processed_nodes = []

# --- Create a NULL for each output ---
for i, label in enumerate(output_labels):
    # Create the NULL node.
    null_node = parent.createNode("null", f"OUT_{label}")

    # Connect the selected node's output to the new NULL's input.
    null_node.setInput(0, selected_node, i)

    # Calculate and set the position for the NULL node.
    null_pos = hou.Vector2(pos.x() + 3, pos.y() - i * 1.5)
    null_node.setPosition(null_pos)

    # Set 'outputname1' parameter if it exists.
    # Note: A standard NULL COP does not have this parameter.
    # This will only work on nodes that have this specific parameter.
    output_name_parm = null_node.parm("outputname1").set(label)

    # Add the new NULL and its label to our list for the next step.
    processed_nodes.append((null_node, label))


# --- Create a ROP for each new NULL ---
for null_node, label in processed_nodes:
    # Get the position of the current NULL node.
    null_pos = null_node.position()

    # Create a 'comp' (Composite Output) node.
    # We'll name it based on the label.
    rop_name = f"ROP_{label}"
    rop_node = parent.createNode("rop_image", rop_name)

    # Connect the NULL node's output to the new ROP node's input.
    rop_node.setInput(0, null_node, 0)

    # Position the ROP node to the right of the NULL node.
    rop_pos = hou.Vector2(null_pos.x() + 3, null_pos.y())
    rop_node.setPosition(rop_pos)

    # Set the AOV Image Plane parameter on the rop_node to the label.
    rop_node.parm("aov1").set(label)

]]></script>
  </tool>

  <tool name="Relink Files" label="Relink Files" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou

# --- Version-Agnostic PySide Import ---
# For compatibility with Houdini 20+ (PySide6) and older versions (PySide2).
try:
    from PySide6 import QtWidgets, QtCore
except ImportError:
    from PySide2 import QtWidgets, QtCore

# --- Global variable to hold a single instance of our dialog ---
# This prevents opening multiple copies of the tool window.
path_replacer_dialog_instance = None


# --- Node/Parameter Mapping ---
NODE_PARAM_MAP = {
    # Karma
    'mtlximage': 'file',
    
    # Redshift
    'redshift::TextureSampler': 'tex0',
    
    # SOPs
    'file': 'file',
    'alembic': 'fileName', 
    
    # Octane
    'octane::NT_TEX_IMAGE': 'A_FILENAME',
    'octane::NT_TEX_FLOATIMAGE': 'A_FILENAME',
    'octane::NT_TEX_ALPHA': 'A_FILENAME'
}


class PathReplacerDialog(QtWidgets.QDialog):
    """A non-modal dialog window for path replacement."""
    def __init__(self, parent=hou.ui.mainQtWindow()):
        super(PathReplacerDialog, self).__init__(parent)

        self.setWindowTitle("File Path Replacer")
        self.setMinimumWidth(450)
        
        # This attribute makes the window appear on top, but it's not strictly modal.
        self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)

        # --- UI Setup ---
        self.main_layout = QtWidgets.QVBoxLayout(self)
        
        info_label = QtWidgets.QLabel("Select a parent node, then enter paths and click Replace.")
        info_label.setStyleSheet("font-style: italic; color: #888;")

        form_layout = QtWidgets.QFormLayout()
        self.original_path_input = QtWidgets.QLineEdit()
        self.new_path_input = QtWidgets.QLineEdit()
        form_layout.addRow("Original Path:", self.original_path_input)
        form_layout.addRow("New Path:", self.new_path_input)

        button_layout = QtWidgets.QHBoxLayout()
        self.replace_button = QtWidgets.QPushButton("Replace")
        self.close_button = QtWidgets.QPushButton("Close")
        button_layout.addStretch() 
        button_layout.addWidget(self.replace_button)
        button_layout.addWidget(self.close_button)

        self.main_layout.addWidget(info_label)
        self.main_layout.addLayout(form_layout)
        self.main_layout.addLayout(button_layout)

        # --- Connections ---
        self.replace_button.clicked.connect(self.run_replacement_logic)
        self.close_button.clicked.connect(self.close)

    def run_replacement_logic(self):
        """This function is triggered by the 'Replace' button."""
        start_node = None
        selected_nodes = hou.selectedNodes()
        if not selected_nodes:
            hou.ui.displayMessage("Please select a parent node in the network first.", title="Error")
            return
        
        start_node = selected_nodes[0]
        
        original_path = self.original_path_input.text()
        new_path = self.new_path_input.text()

        if not original_path:
            hou.ui.displayMessage("The 'Original Path' field cannot be empty.", title="Error")
            return

        updated_nodes_count = 0
        with hou.undos.group("Replace File Paths"):
            for node in start_node.allSubChildren():
                node_type_name = node.type().name()
                
                if node_type_name in NODE_PARAM_MAP:
                    param_name = NODE_PARAM_MAP[node_type_name]
                    file_parm = node.parm(param_name)
                    
                    if file_parm:
                        current_raw_path = file_parm.unexpandedString()
                        if original_path in current_raw_path:
                            new_raw_path = current_raw_path.replace(original_path, new_path)
                            file_parm.set(new_raw_path)
                            updated_nodes_count += 1
        
        hou.ui.displayMessage(
            f"Updated {updated_nodes_count} file path(s) within '{start_node.name()}'.",
            title="Process Complete"
        )
        
    def closeEvent(self, event):
        """Cleans up our global instance variable when the window is closed."""
        global path_replacer_dialog_instance
        path_replacer_dialog_instance = None
        super(PathReplacerDialog, self).closeEvent(event)


def show_tool():
    """
    This is the main function called by the shelf button.
    It manages the creation and display of the dialog instance.
    """
    global path_replacer_dialog_instance
    
    if path_replacer_dialog_instance:
        path_replacer_dialog_instance.raise_()
        path_replacer_dialog_instance.activateWindow()
    else:
        path_replacer_dialog_instance = PathReplacerDialog()
        path_replacer_dialog_instance.show()

# --- Entry point for the shelf tool ---
show_tool()]]></script>
  </tool>

  <tool name="Loop Sequence" label="Loop Sequence" icon="custom_hda_icon">
    <helpText><![CDATA[Loops a loaded sequence.]]></helpText>
    <script scriptType="python"><![CDATA[import hou
import glob
import re
import os

nodes = hou.selectedNodes()

for node in nodes:
    parm = node.parm("file") or node.parm("filename") or node.parm("map")

    if parm:
        raw_path = parm.unexpandedString()
        match = re.search(r'\$F(\d+)', raw_path)

        if match:
            f_token = match.group(0)
            padding_str = match.group(1)
            padding_val = int(padding_str)
            
            glob_path = raw_path.replace(f_token, "*")
            expanded_path = hou.expandString(glob_path)
            files = glob.glob(expanded_path)
            file_count = len(files)
            
            zero_filename = raw_path.replace(f_token, "0".zfill(padding_val))
            expanded_zero = hou.expandString(zero_filename)
            
            if os.path.exists(expanded_zero):
                expr = "`padzero({}, ($F - 1) % {})`".format(padding_str, file_count)
            else:
                expr = "`padzero({}, ($F - 1) % {} + 1)`".format(padding_str, file_count)
            
            parm.set(raw_path.replace(f_token, expr))]]></script>
  </tool>

  <tool name="Asset Manager" label="Asset Manager" icon="custom_hda_icon">
    <script scriptType="python"><![CDATA[import hou
import os
import re
import fnmatch
from PySide6 import QtWidgets, QtCore, QtGui

# ==============================================================================
# CONFIGURATION
# ==============================================================================
NODE_MAPPING = {
    'file': 'file',                  # File SOP
    'alembic': 'fileName',           # Alembic SOP
    'filecache': 'file',             # File Cache (Read mode)
    'mtlximage': 'file',             # MaterialX Image
    'mtlxunknown': 'file',           # MaterialX Unknown
    'texture::2.0': 'map',           # Principled Shader texture
    'rs_texture': 'tex0',            # Redshift Texture
    'arnold_image': 'filename',      # Arnold Image
    'usdimport': 'filepath1',        # USD Import
    'sublayer': 'filepath1',         # LOP Sublayer
    'bonemaptarget': 'file',         # KineFX Bone Map
    
    # Octane Support
    'NT_TEX_IMAGE': 'A_FILENAME',    
    'octane::NT_TEX_IMAGE': 'A_FILENAME', 
}

# ==============================================================================
# CUSTOM DELEGATE (Highlighting Only)
# ==============================================================================
class AssetDelegate(QtWidgets.QStyledItemDelegate):
    def __init__(self, parent=None):
        super(AssetDelegate, self).__init__(parent)
        self.regex_pattern = ""

    def set_regex(self, regex_str):
        self.regex_pattern = regex_str

    def paint(self, painter, option, index):
        # 1. Init Style
        self.initStyleOption(option, index)
        
        # 2. Prevent default text drawing (we draw HTML manually)
        option.text = ""
        
        # 3. Draw standard control (backgrounds, selection, focus)
        style = option.widget.style() if option.widget else QtWidgets.QApplication.style()
        style.drawControl(QtWidgets.QStyle.CE_ItemViewItem, option, painter, option.widget)

        # 4. Get Data
        text = index.data(QtCore.Qt.DisplayRole)
        if not text: return

        # 5. Determine Text Color
        fg_brush = index.data(QtCore.Qt.ForegroundRole)
        if option.state & QtWidgets.QStyle.State_Selected:
            text_color = "#ffffff"
        else:
            text_color = fg_brush.color().name() if fg_brush else "#dadada"

        # 6. HTML Highlighting Logic
        html_text = text
        if self.regex_pattern:
            try:
                def hl(match):
                    return f"<span style='background-color: #d4aa00; color: #000000; font-weight:bold;'>{match.group(0)}</span>"
                
                highlighted = re.sub(self.regex_pattern, hl, text, flags=re.IGNORECASE)
                html_text = f"<div style='color: {text_color}; white-space: pre;'>{highlighted}</div>"
            except:
                html_text = f"<div style='color: {text_color}; white-space: pre;'>{text}</div>"
        else:
             html_text = f"<div style='color: {text_color}; white-space: pre;'>{text}</div>"

        # 7. Draw HTML
        painter.save()
        
        # Adjust rect for padding
        text_rect = option.rect.adjusted(5, 0, -5, 0)

        doc = QtGui.QTextDocument()
        doc.setDefaultStyleSheet("div { font-family: Source Sans Pro, Segoe UI, sans-serif; font-size: 13px; }")
        doc.setHtml(html_text)
        
        # Vertical Center
        painter.translate(text_rect.left(), text_rect.top() + (text_rect.height() - doc.size().height()) / 2)
        doc.drawContents(painter)
        
        painter.restore()

# ==============================================================================
# MAIN WINDOW
# ==============================================================================
class AssetManager(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super(AssetManager, self).__init__(parent)
        
        self.setWindowTitle("Houdini Asset Inspector")
        self.resize(1200, 700)
        self.setStyleSheet("""
            QGroupBox { font-weight: bold; border: 1px solid #555; margin-top: 6px; padding-top: 10px; }
            QGroupBox::title { subcontrol-origin: margin; left: 10px; padding: 0 3px; }
            QPushButton { padding: 5px; }
        """)
        
        layout = QtWidgets.QVBoxLayout()
        self.setLayout(layout)
        
        # --- TOOLBAR ---
        toolbar_layout = QtWidgets.QHBoxLayout()
        
        # Refresh Button
        self.btn_refresh = QtWidgets.QPushButton(" Refresh List")
        self.btn_refresh.clicked.connect(self.refresh_assets)
        self.btn_refresh.setStyleSheet("background-color: #d48806; color: white; font-weight: bold;")
        
        # Filter Input
        self.le_filter = QtWidgets.QLineEdit()
        self.le_filter.setPlaceholderText("Filter assets... (Use * for wildcards)")
        self.le_filter.textChanged.connect(self.on_top_filter_changed)
        
        # Path Utils
        self.btn_localize = QtWidgets.QPushButton("Make Relative ($HIP)")
        self.btn_localize.setToolTip("Convert absolute paths to $HIP relative paths")
        self.btn_localize.clicked.connect(self.make_paths_relative)
        
        self.btn_globalize = QtWidgets.QPushButton("Make Absolute")
        self.btn_globalize.setToolTip("Expand $HIP/$JOB to full paths")
        self.btn_globalize.clicked.connect(self.make_paths_absolute)
        
        toolbar_layout.addWidget(self.btn_refresh)
        toolbar_layout.addWidget(self.le_filter)
        toolbar_layout.addWidget(QtWidgets.QLabel("|"))
        toolbar_layout.addWidget(self.btn_localize)
        toolbar_layout.addWidget(self.btn_globalize)
        
        layout.addLayout(toolbar_layout)
        
        # --- TABLE VIEW ---
        self.table = QtWidgets.QTableWidget()
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(["Status", "Node Name", "Node Type", "Current Path", "Full Node Path"])
        
        # Headers
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.ResizeToContents) # Status
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.ResizeToContents) # Name
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.ResizeToContents) # Type
        header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeMode.Stretch)          # Path
        
        # Settings
        self.table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.table.setAlternatingRowColors(True)
        self.table.verticalHeader().setVisible(False)
        
        # DISABLE EDITING
        self.table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        
        self.table.cellDoubleClicked.connect(self.on_double_click)
        
        # Install Delegate only on the Path Column (Col 3) for highlighting
        self.delegate = AssetDelegate(self.table)
        self.table.setItemDelegateForColumn(3, self.delegate)
        
        # Context Menu
        self.table.setContextMenuPolicy(QtCore.Qt.ContextMenuPolicy.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.open_context_menu)
        
        layout.addWidget(self.table)
        
        # --- BOTTOM: SMART REPLACE ---
        fr_group = QtWidgets.QGroupBox("Find & Replace (Selected Assets)")
        fr_layout = QtWidgets.QHBoxLayout()
        fr_group.setLayout(fr_layout)
        
        self.le_find_wild = QtWidgets.QLineEdit()
        self.le_find_wild.setPlaceholderText("Find (e.g. *texture* or v00?)")
        self.le_find_wild.textChanged.connect(self.on_bottom_replace_changed)
        
        self.le_replace_wild = QtWidgets.QLineEdit()
        self.le_replace_wild.setPlaceholderText("Replace with...")
        self.le_replace_wild.textChanged.connect(self.on_bottom_replace_changed)
        
        self.btn_replace = QtWidgets.QPushButton("Replace")
        self.btn_replace.clicked.connect(self.batch_replace_wildcard)
        
        fr_layout.addWidget(QtWidgets.QLabel("Find:"))
        fr_layout.addWidget(self.le_find_wild)
        fr_layout.addWidget(QtWidgets.QLabel("Replace:"))
        fr_layout.addWidget(self.le_replace_wild)
        fr_layout.addWidget(self.btn_replace)
        
        layout.addWidget(fr_group)
        
        self.cached_nodes = [] 
        self.refresh_assets()

    # ==========================================================================
    # LOGIC: STATUS CHECK
    # ==========================================================================
    def check_file_status(self, raw_path, expanded_path):
        """ Returns (StatusText, Color) """
        if not raw_path or raw_path.strip() == "":
            return "EMPTY", QtGui.QColor(100, 100, 100) # Grey
        
        seq_tokens = ["$F", "<UDIM>", "<uvtile>", "%(UDIM)", "%04d", "$T", "`"]
        if any(token in raw_path for token in seq_tokens):
            return "VAR", QtGui.QColor(255, 170, 0) # Orange
        
        if os.path.exists(expanded_path):
            return "OK", QtGui.QColor(100, 200, 100) # Green
        
        return "MISSING", QtGui.QColor(255, 60, 60) # Red

    def update_row(self, row, node, parm):
        raw_val = parm.rawValue()
        try: expanded_val = parm.eval()
        except: expanded_val = raw_val
        
        status_text, text_color = self.check_file_status(raw_val, expanded_val)
        
        # 0: Status Text
        item_status = QtWidgets.QTableWidgetItem(status_text)
        item_status.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        item_status.setForeground(QtGui.QBrush(text_color))
        # Bold font for status
        font = item_status.font()
        font.setBold(True)
        item_status.setFont(font)
        self.table.setItem(row, 0, item_status)
        
        # 1: Name
        item_name = QtWidgets.QTableWidgetItem(node.name())
        item_name.setForeground(QtGui.QBrush(text_color))
        self.table.setItem(row, 1, item_name)
        
        # 2: Type
        item_type = QtWidgets.QTableWidgetItem(node.type().name())
        item_type.setForeground(QtGui.QBrush(text_color))
        self.table.setItem(row, 2, item_type)
        
        # 3: Path (Color applied via ForegroundRole, Highlighting via Delegate)
        item_path = QtWidgets.QTableWidgetItem(raw_val)
        item_path.setForeground(QtGui.QBrush(text_color))
        self.table.setItem(row, 3, item_path)
        
        # 4: Full Path
        item_full = QtWidgets.QTableWidgetItem(node.path())
        item_full.setForeground(QtGui.QBrush(text_color))
        self.table.setItem(row, 4, item_full)

    # ==========================================================================
    # LOGIC: PATH UTILITIES
    # ==========================================================================
    def make_paths_relative(self):
        """ Replaces matching prefix with $HIP """
        selected_rows = self.get_selected_indices()
        if not selected_rows: return

        hip = hou.getenv("HIP").replace("\\", "/")
        
        count = 0
        with hou.undos.group("Localize Paths"):
            for i in selected_rows:
                node, parm = self.cached_nodes[i]
                path = parm.eval().replace("\\", "/")
                
                if path.startswith(hip):
                    rel_path = path.replace(hip, "$HIP")
                    parm.set(rel_path)
                    self.update_row(i, node, parm)
                    count += 1
        hou.ui.setStatusMessage(f"Localized {count} paths.")

    def make_paths_absolute(self):
        """ Expands $HIP/$JOB to full paths """
        selected_rows = self.get_selected_indices()
        if not selected_rows: return
        
        count = 0
        with hou.undos.group("Globalize Paths"):
            for i in selected_rows:
                node, parm = self.cached_nodes[i]
                full_path = parm.eval() # eval() returns the absolute expanded path
                raw_path = parm.rawValue()
                
                if raw_path != full_path:
                    parm.set(full_path)
                    self.update_row(i, node, parm)
                    count += 1
        hou.ui.setStatusMessage(f"Globalized {count} paths.")

    # ==========================================================================
    # REGEX LOGIC
    # ==========================================================================
    def get_smart_regex(self, find_pat, repl_pat=""):
        if not find_pat: return ""
        # Smart Strip
        if find_pat.startswith('*') and repl_pat.startswith('*'):
            find_pat = find_pat[1:]
        if find_pat.endswith('*') and repl_pat.endswith('*'):
            find_pat = find_pat[:-1]
        
        regex_str = re.escape(find_pat)
        regex_str = regex_str.replace(r'\*', '.*').replace(r'\?', '.')
        return regex_str

    # ==========================================================================
    # EVENTS
    # ==========================================================================
    def refresh_assets(self):
        self.table.setRowCount(0)
        self.cached_nodes = []
        all_nodes = hou.node("/").allSubChildren()
        
        row = 0
        for node in all_nodes:
            type_name = node.type().name()
            if type_name in NODE_MAPPING:
                param_name = NODE_MAPPING[type_name]
                parm = node.parm(param_name)
                if parm:
                    self.cached_nodes.append((node, parm))
                    self.table.insertRow(row)
                    self.update_row(row, node, parm)
                    self.table.item(row, 0).setData(QtCore.Qt.ItemDataRole.UserRole, row)
                    row += 1
        
        self.on_top_filter_changed() 
        self.setWindowTitle(f"Houdini Asset Inspector - Found {row} items")

    def on_top_filter_changed(self):
        pattern = self.le_filter.text()
        
        # 1. Update Delegate (Highlighting)
        regex = ""
        if pattern:
            if not any(c in pattern for c in ['*', '?']):
                regex = re.escape(pattern)
            else:
                regex = fnmatch.translate(pattern).replace(r'\Z', '').replace(r'(?s:', '').replace(r')', '')
        
        self.delegate.set_regex(regex)
        self.table.viewport().update()
        
        # 2. Filter Rows
        pattern_lower = pattern.lower()
        if not pattern_lower:
            for i in range(self.table.rowCount()): self.table.setRowHidden(i, False)
            return

        if not any(c in pattern_lower for c in ['*', '?']):
            pattern_lower = f"*{pattern_lower}*"

        for i in range(self.table.rowCount()):
            path_item = self.table.item(i, 3)
            path_text = path_item.text().lower()
            if fnmatch.fnmatch(path_text, pattern_lower):
                self.table.setRowHidden(i, False)
            else:
                self.table.setRowHidden(i, True)

    def on_bottom_replace_changed(self):
        find_pat = self.le_find_wild.text()
        repl_pat = self.le_replace_wild.text()
        regex = self.get_smart_regex(find_pat, repl_pat)
        self.delegate.set_regex(regex)
        self.table.viewport().update()

    def batch_replace_wildcard(self):
        find_pat = self.le_find_wild.text()
        repl_pat = self.le_replace_wild.text()
        if not find_pat: return

        selected_rows = self.get_selected_indices()
        if not selected_rows: return

        # Smart Strip Logic for replacement
        final_repl = repl_pat
        if find_pat.startswith('*') and repl_pat.startswith('*'):
            final_repl = final_repl[1:]
        if find_pat.endswith('*') and repl_pat.endswith('*'):
            final_repl = final_repl[:-1]

        regex_str = self.get_smart_regex(find_pat, repl_pat)

        count = 0
        with hou.undos.group("Asset Manager Replace"):
            for i in selected_rows:
                node, parm = self.cached_nodes[i]
                current_raw = parm.rawValue()
                try:
                    new_raw = re.sub(regex_str, final_repl, current_raw)
                    if new_raw != current_raw:
                        parm.set(new_raw)
                        self.update_row(i, node, parm)
                        count += 1
                except: pass
        hou.ui.setStatusMessage(f"Replaced text in {count} selected nodes.")

    def get_selected_indices(self):
        rows = set()
        for item in self.table.selectedItems(): rows.add(item.row())
        return list(rows)

    # ==========================================================================
    # ACTIONS
    # ==========================================================================
    def open_context_menu(self, position):
        menu = QtWidgets.QMenu()
        menu.addAction("Search Filename in Directory...", self.search_in_directory)
        menu.addAction("Browse/Relink Manual...", self.browse_new_path)
        menu.addSeparator()
        menu.addAction("Select in Network", self.select_in_network)
        menu.exec(self.table.viewport().mapToGlobal(position))

    def search_in_directory(self):
        rows = self.get_selected_indices()
        if not rows: return
        search_root = hou.ui.selectFile(title="Select Root", file_type=hou.fileType.Directory)
        if not search_root: return
        search_root = hou.expandString(search_root)
        
        file_map = {}
        # Index directory
        for root, dirs, files in os.walk(search_root):
            for file in files:
                if file not in file_map:
                    file_map[file] = os.path.join(root, file).replace("\\", "/")
        
        count = 0
        with hou.undos.group("Smart Search"):
            for idx in rows:
                node, parm = self.cached_nodes[idx]
                fname = os.path.basename(parm.rawValue().replace("\\", "/"))
                if fname in file_map:
                    parm.set(file_map[fname])
                    self.update_row(idx, node, parm)
                    count += 1
        hou.ui.setStatusMessage(f"Found {count} files.")

    def browse_new_path(self):
        rows = self.get_selected_indices()
        if not rows: return
        idx = rows[0]
        node, parm = self.cached_nodes[idx]
        start_dir = parm.eval() or hou.getenv("HIP")
        new_file = hou.ui.selectFile(start_directory=start_dir, title="Relink")
        if new_file:
            parm.set(new_file)
            self.update_row(idx, node, parm)

    def select_in_network(self):
        rows = self.get_selected_indices()
        if not rows: return
        for n in hou.selectedNodes(): n.setSelected(False)
        first = None
        for idx in rows:
            node, _ = self.cached_nodes[idx]
            node.setSelected(True)
            if not first: first = node
        if first:
            p = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
            if p: p.cd(first.parent().path()); p.homeToSelection()
    
    def on_double_click(self, row, col):
        self.select_in_network()

# Window Management
asset_manager_window = None
def show_asset_manager():
    global asset_manager_window
    if asset_manager_window: asset_manager_window.close()
    parent = hou.qt.mainWindow()
    asset_manager_window = AssetManager(parent)
    asset_manager_window.show()

show_asset_manager()]]></script>
  </tool>
</shelfDocument>
